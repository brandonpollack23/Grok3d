/* Copyright (c) 2017 Brandon Pollack
* Contact @ grok3d@gmail.com
* This file is available under the MIT license included in the project
*/

#include "grok3d/grok3d.h"

#include <cmath>
#include <tuple>
#include <iostream>

using namespace Grok3d;
using namespace Grok3d::Entities;
using namespace Grok3d::Components;
using namespace Grok3d::ShaderManager;

static constexpr auto kFirstUniformName = "ourColor";

class FirstUniformShader;
auto GetEngineInitializationFunction(char **args) -> std::function<GRK_Result (GRK_EntityComponentManager&)>;
auto LoadVertices() -> std::unique_ptr<float[]>;
auto HelloChangingTriangleTest(char *args[]) -> void;;
auto AddComponent(GRK_EntityHandle &triangleEntity,
                  std::unique_ptr<float[]>& vertexes,
                  const FirstUniformShader &shaderProgram) -> void;

/**
 * @class
 *
 * This is an example of a @link ShaderProgram class.  They all extend ShaderProgram so they can inherit the loading
 * functionality, but that's the extent of it.
 *
 * In the future these classes can be auto generated by a tool I'll make to be consumed more easily in Grok3d.
 *
 * I'll also implement a generic programmable shader class that'll use some heap and map uniform names to their handles
 * in a std::map.
 */
class FirstUniformShader : public ShaderProgram {
 public:
  FirstUniformShader(
      const char * const vertexShader,
      const char * const fragmentShader,
      const char * const uniform) : ShaderProgram(vertexShader, fragmentShader) {
    theUniform_ = static_cast<GRK_UniformID>(glGetUniformLocation(shaderProgramId, uniform));
    if (theUniform_ < 0) {
      std::cout << "Error getting uniform \"" << uniform << "\" from shaders: "
                << vertexShader << " " << fragmentShader << std::endl;
      std::exit(-1);
    }
  }

  auto SetTheUniformFloat(float r, float g, float b, float w) -> void {
    glUniform4f(theUniform_, r, g, b, w);
  }

 private:
  GRK_UniformID theUniform_;
};

/**
 * @class
 *
 * A basic behaviour that updates the shader's color setting uniform over time.
 *
 * <p>DUH DUH DUH DISSSCOOOO TRIANGLE!!!</p>
 */
class ChangeColorBehaviour : public GRK_GameBehaviourBase {
 public:
  ChangeColorBehaviour(GRK_EntityHandle entity, FirstUniformShader shader) noexcept
      : GRK_GameBehaviourBase(entity),
        renderComponent(entity.GetComponent<GRK_RenderComponent>()),
        shader(shader) {}

  auto Update(double dt) -> void override {
    time = time + dt;

    // This is just like extracting each member and passing it as arguments to shader.SetTheUniformFloat.
    std::apply(
        &FirstUniformShader::SetTheUniformFloat,
        std::tuple_cat(std::tuple(&shader), CalculateDiscoColor(time)));
  }

 private:
  auto CalculateDiscoColor(double time) -> std::tuple<float, float, float, float> {
    return std::tuple(
        std::sin(2 * time) / 2.0f + .5f,
        std::cos(2 * time) / 2.0f + .5f,
        std::sin(.5f * time) / 2.0f + .5f,
        1.0f);
  }

 private:
  GRK_ComponentHandle<GRK_RenderComponent> renderComponent;
  FirstUniformShader shader;
  double time = 0;
};

static float triangleFloats[] = {
    -0.5f, -0.5f, 0.0f,
    0.5f, -0.5f, 0.0f,
    0.0f, 0.5f, 0.0
};

auto main(int argc, char *argv[]) -> int {
  if (argc < 3) {
    std::cout << "Triangle test requires a vertex and frag shader passed as arguments 1 and 2" << std::endl;
    return -1;
  } else {
    HelloChangingTriangleTest(argv);
  }

  return 0;
}

auto HelloChangingTriangleTest(char **args) -> void {
  auto engineInitialization = GetEngineInitializationFunction(args);
  GRK_Engine engine(engineInitialization);
  engine.Run();
}

auto GetEngineInitializationFunction(char *args[]) -> std::function<GRK_Result(GRK_EntityComponentManager &)> {
  return [args](GRK_EntityComponentManager &ecm) -> GRK_Result {
    auto triangleEntity = ecm.CreateEntity();

    std::unique_ptr<float[]> vertexes = LoadVertices();
    auto shaderProgram = FirstUniformShader(args[1], args[2], kFirstUniformName);
    AddComponent(triangleEntity, vertexes, shaderProgram);

    GRK_GameLogicComponent glc;
    glc.RegisterBehaviour(
        std::make_unique<ChangeColorBehaviour>(triangleEntity, shaderProgram));

    triangleEntity.AddComponent(std::move(glc));

    return GRK_Result::Ok;
  };
}

std::unique_ptr<float[]> LoadVertices() {
  auto vertexes = std::make_unique<float[]>(9);
  std::copy(triangleFloats, &triangleFloats[9], vertexes.get());
  return vertexes;
}

void AddComponent(GRK_EntityHandle &triangleEntity,
                  std::unique_ptr<float[]> &vertexes,
                  const FirstUniformShader &shaderProgram) {
  triangleEntity.AddComponent(
      std::move(GRK_RenderComponent(
          vertexes,
          3,
          sizeof(float),
          GRK_GL_PrimitiveType::Unsigned_Int,
          nullptr,
          0,
          GRK_OpenGLPrimitive::GL_Triangles,
          shaderProgram.GetId())));
}
