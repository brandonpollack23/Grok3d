/* Copyright (c) 2018 Brandon Pollack
* Contact @ grok3d@gmail.com
* This file is available under the MIT license included in the project
*/

#include "grok3d/grok3d.h"

#include <cmath>
#include <tuple>
#include <iostream>

using namespace Grok3d;
using namespace ShaderManager;

static constexpr auto kFirstUniformName = "ourColor";

class FirstUniformShader;
auto GetEngineInitializationFunction(char **args) -> std::function<GRK_Result (GRK_EntityComponentManager&)>;
auto LoadVertices(int numVertices) -> std::unique_ptr<float[]>;
auto HelloChangingTriangleTest(char *args[]) -> void;;
auto CreateVertexAttributes() -> std::tuple<std::unique_ptr<GRK_VertexAttribute[]>, GLsizei>;
auto AddSingleUniformRenderComponent(GRK_EntityHandle &triangleEntity, const FirstUniformShader &shaderProgram) -> void;
auto AddDiscoLogicComponent(GRK_EntityHandle &triangleEntity, const FirstUniformShader &shaderProgram) -> void;

/**
 * @class
 *
 * This is an example of a @link ShaderProgram class.  They all extend ShaderProgram so they can inherit the loading
 * functionality, but that's the extent of it.
 *
 * In the future these classes can be auto generated by a tool I'll make to be consumed more easily in Grok3d.
 *
 * I'll also implement a generic programmable shader class that'll use some heap and map uniform names to their handles
 * in a std::map.
 */
class FirstUniformShader : public ShaderProgram {
 public:
  FirstUniformShader(
      const char * const vertexShader,
      const char * const fragmentShader,
      const char * const uniform) : ShaderProgram(vertexShader, fragmentShader) {
    theUniform_ = static_cast<GRK_UniformID>(glGetUniformLocation(shaderProgramId, uniform));
    if (theUniform_ < 0) {
      std::cout << "Error getting uniform \"" << uniform << "\" from shaders: "
                << vertexShader << " " << fragmentShader << std::endl;
      std::exit(-1);
    }
  }

  auto SetTheUniformFloat(float r, float g, float b, float w) -> void {
    glUniform4f(theUniform_, r, g, b, w);
  }

 private:
  GRK_UniformID theUniform_;
};

/**
 * @class
 *
 * A basic behaviour that updates the shader's color setting uniform over time.
 *
 * <p>DUH DUH DUH DISSSCOOOO TRIANGLE!!!</p>
 */
class ChangeColorBehaviour : public GRK_GameBehaviourBase {
 public:
  ChangeColorBehaviour(GRK_EntityHandle entity, FirstUniformShader shader) noexcept
      : GRK_GameBehaviourBase(entity),
        renderComponent(entity.GetComponent<GRK_RenderComponent>()),
        shader(shader) {}

  auto Update(double dt) -> void override {
    time = time + dt;

    // This is just like extracting each member and passing it as arguments to shader.SetTheUniformFloat.
    std::apply(
        &FirstUniformShader::SetTheUniformFloat,
        std::tuple_cat(std::tuple(&shader), CalculateDiscoColor(time)));
  }

 private:
  auto CalculateDiscoColor(double time) -> std::tuple<float, float, float, float> {
    return std::tuple(
        std::sin(2 * time) / 2.0f + .5f,
        std::cos(2 * time) / 2.0f + .5f,
        std::sin(.5f * time) / 2.0f + .5f,
        1.0f);
  }

 private:
  GRK_ComponentHandle<GRK_RenderComponent> renderComponent;
  FirstUniformShader shader;
  double time = 0;
};

static float triangleFloats[] = {
    -0.5f, -0.5f, 0.0f,
    0.5f, -0.5f, 0.0f,
    0.0f, 0.5f, 0.0
};

auto main(int argc, char *argv[]) -> int {
  if (argc < 3) {
    std::cout << "Triangle test requires a vertex and frag shader passed as arguments 1 and 2" << std::endl;
    return -1;
  } else {
    HelloChangingTriangleTest(argv);
  }

  return 0;
}

auto HelloChangingTriangleTest(char **args) -> void {
  GRK_Engine engine(GetEngineInitializationFunction(args));
  engine.Run();
}

auto GetEngineInitializationFunction(char *args[]) -> std::function<GRK_Result(GRK_EntityComponentManager &)> {
  return [args](GRK_EntityComponentManager &ecm) -> GRK_Result {
    auto triangleEntity = ecm.CreateEntity();

    auto shaderProgram = FirstUniformShader(args[1], args[2], kFirstUniformName);

    AddSingleUniformRenderComponent(triangleEntity, shaderProgram);
    AddDiscoLogicComponent(triangleEntity, shaderProgram);

    return GRK_Result::Ok;
  };
}

void AddSingleUniformRenderComponent(GRK_EntityHandle &triangleEntity, const FirstUniformShader &shaderProgram) {
  std::unique_ptr<float[]> vertexes = LoadVertices(sizeof(triangleFloats) / sizeof(float));
  auto vertexAttributes = CreateVertexAttributes();

  triangleEntity.AddComponent(
        GRK_RenderComponent(
            vertexes,
            3,
            sizeof(float),
            GRK_GL_PrimitiveType::Unsigned_Int,
            nullptr,
            0,
            GRK_OpenGLPrimitive::GL_Triangles,
            shaderProgram.GetId(),
            std::get<0>(vertexAttributes).get(),
            std::get<1>(vertexAttributes)));
}

std::unique_ptr<float[]> LoadVertices(int numVertices) {
  auto vertexes = std::make_unique<float[]>(static_cast<size_t>(numVertices));
  std::copy(triangleFloats, &triangleFloats[numVertices], vertexes.get());
  return vertexes;
}

auto CreateVertexAttributes() -> std::tuple<std::unique_ptr<GRK_VertexAttribute[]>, GLsizei> {
  GLsizei numAttributes = 1;
  auto va = std::make_unique<GRK_VertexAttribute[]>(1);
  va[0] = {
      0, // index
      3, // size
      GL_FLOAT, // type
      GL_FALSE, // normalize
      numAttributes * kDimensions * sizeof(float), // stride
      reinterpret_cast<void*>(0)
  };

  return std::make_tuple(std::move(va), numAttributes);
}

auto AddDiscoLogicComponent(GRK_EntityHandle &triangleEntity, const FirstUniformShader &shaderProgram) -> void {
  GRK_GameLogicComponent glc;
  glc.RegisterBehaviour(
      std::make_unique<ChangeColorBehaviour>(triangleEntity, shaderProgram));

  triangleEntity.AddComponent(std::move(glc));
}

